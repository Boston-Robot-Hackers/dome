##############################################################################
# Nav2 Navigation Parameters - CORRECTED & OPTIMIZED
# Robot: Differential Drive, Radius 0.3m
# Controller: MPPI (Model Predictive Path Integral)
##############################################################################

amcl:
  ros__parameters:
    # Motion model noise parameters - tune based on your robot's odometry accuracy
    alpha1: 0.2  # Rotation noise from rotation
    alpha2: 0.2  # Rotation noise from translation
    alpha3: 0.2  # Translation noise from translation
    alpha4: 0.2  # Translation noise from rotation
    alpha5: 0.2  # Strafe noise (for omni robots)
    
    # Frame configuration
    base_frame_id: "base_footprint"  # Robot base frame (consistent across all nodes)
    global_frame_id: "map"           # Global/map frame
    odom_frame_id: "odom"            # Odometry frame
    
    # Laser scan configuration
    beam_skip_distance: 0.5
    beam_skip_error_threshold: 0.9
    beam_skip_threshold: 0.3
    do_beamskip: false
    lambda_short: 0.1
    laser_likelihood_max_dist: 2.0
    laser_max_range: 100.0
    laser_min_range: -1.0
    laser_model_type: "likelihood_field"  # likelihood_field or beam
    max_beams: 60                         # Downsample laser scans for performance
    scan_topic: scan
    
    # Particle filter configuration
    max_particles: 2000     # Maximum number of particles
    min_particles: 500      # Minimum number of particles
    pf_err: 0.05           # Particle filter error threshold
    pf_z: 0.99             # Particle filter z-statistic
    
    # Recovery parameters (set to 0 to disable)
    recovery_alpha_fast: 0.0
    recovery_alpha_slow: 0.0
    
    resample_interval: 1    # Resample every N updates
    robot_model_type: "nav2_amcl::DifferentialMotionModel"  # Differential drive robot
    save_pose_rate: 0.5     # Hz - rate to save pose estimates
    
    # Laser likelihood field model parameters
    sigma_hit: 0.2   # Standard deviation of hit distribution
    z_hit: 0.5       # Weight for hit distribution
    z_max: 0.05      # Weight for max range distribution
    z_rand: 0.5      # Weight for random distribution
    z_short: 0.05    # Weight for short distribution
    
    tf_broadcast: true              # Broadcast map->odom transform
    transform_tolerance: 0.2        # FIXED: Was 1.0s (too high!) - now 200ms for tighter localization
    
    # Motion update thresholds - require this much movement before updating
    update_min_a: 0.2   # Minimum angular movement (radians)
    update_min_d: 0.25  # Minimum linear movement (meters)

##############################################################################

bt_navigator:
  ros__parameters:
    # Frame configuration - CONSISTENT with other nodes
    global_frame: map
    robot_base_frame: base_footprint  # FIXED: Was base_link, now consistent
    odom_topic: /odom
    
    # Behavior tree timing
    bt_loop_duration: 10             # ms - BT tick rate
    default_server_timeout: 20       # seconds
    wait_for_service_timeout: 1000   # ms
    action_server_result_timeout: 900.0
    
    # Navigator plugins
    navigators: ["navigate_to_pose", "navigate_through_poses"]
    navigate_to_pose:
      plugin: "nav2_bt_navigator::NavigateToPoseNavigator"
    navigate_through_poses:
      plugin: "nav2_bt_navigator::NavigateThroughPosesNavigator"
    
    # Error code tracking
    error_code_names:
      - compute_path_error_code
      - follow_path_error_code

##############################################################################

controller_server:
  ros__parameters:
    controller_frequency: 20.0      # Hz - control loop rate (must sustain this!)
    costmap_update_timeout: 0.30    # seconds - max time to wait for costmap
    
    # Velocity thresholds for progress/failure detection
    min_x_velocity_threshold: 0.001
    min_y_velocity_threshold: 0.5    # N/A for differential drive
    min_theta_velocity_threshold: 0.001
    failure_tolerance: 0.3           # Tolerance for path following failure
    
    # Progress and goal checker plugins
    progress_checker_plugins: ["progress_checker"]
    goal_checker_plugins: ["general_goal_checker"]
    controller_plugins: ["FollowPath"]
    use_realtime_priority: false
    
    # Progress checker - ensures robot is making forward progress
    progress_checker:
      plugin: "nav2_controller::SimpleProgressChecker"
      required_movement_radius: 0.5  # meters - must move this far
      movement_time_allowance: 10.0  # seconds - within this time
    
    # Goal checker - determines when goal is reached
    general_goal_checker:
      stateful: True
      plugin: "nav2_controller::SimpleGoalChecker"
      xy_goal_tolerance: 0.25   # meters - position tolerance
      yaw_goal_tolerance: 0.25  # radians - ~14 degrees orientation tolerance
    
    ##########################################################################
    # MPPI Controller - Model Predictive Path Integral Controller
    # Advanced controller that samples many trajectories and picks the best
    ##########################################################################
    FollowPath:
      plugin: "nav2_mppi_controller::MPPIController"
      
      # Trajectory sampling parameters
      time_steps: 56          # Number of time steps to predict ahead
      model_dt: 0.05          # seconds - time step duration (56 * 0.05 = 2.8s lookahead)
      batch_size: 2000        # Number of trajectories to sample (higher = better but slower)
      
      # Acceleration limits (m/s² and rad/s²)
      ax_max: 3.0    # Maximum forward acceleration
      ax_min: -3.0   # Maximum backward acceleration (deceleration)
      ay_max: 3.0    # Lateral acceleration (N/A for diff drive)
      az_max: 3.5    # Maximum angular acceleration
      
      # Velocity noise for sampling (standard deviation)
      vx_std: 0.2  # Forward velocity noise
      vy_std: 0.2  # Lateral velocity noise
      wz_std: 0.4  # Angular velocity noise
      
      # VELOCITY LIMITS - CRITICAL SETTINGS
      vx_max: 0.8    # m/s - maximum forward velocity
      vx_min: -0.35  # m/s - maximum reverse velocity
      vy_max: 0.5    # m/s - lateral velocity (not used for diff drive)
      wz_max: 1.0    # rad/s - maximum angular velocity (~57 deg/s)
      
      # MPPI algorithm parameters
      iteration_count: 1      # Number of MPPI iterations per control cycle
      prune_distance: 1.7     # meters - prune path points closer than this
      transform_tolerance: 0.1
      temperature: 0.3        # Lower = more deterministic, higher = more exploration
      gamma: 0.015           # Discount factor for future costs
      motion_model: "DiffDrive"
      visualize: true        # Publish visualization markers
      regenerate_noises: true
      
      # Trajectory visualization settings
      TrajectoryVisualizer:
        trajectory_step: 5  # Visualize every 5th trajectory
        time_step: 3        # Visualize every 3rd time step
      
      # Ackermann constraints (not applicable for differential drive)
      AckermannConstraints:
        min_turning_r: 0.2
      
      ##########################################################################
      # MPPI Critics - Cost functions that guide trajectory selection
      # Each critic evaluates trajectories and assigns costs
      ##########################################################################
      critics: [
        "ConstraintCritic",    # Enforces velocity/acceleration constraints
        "CostCritic",          # Penalizes proximity to obstacles
        "GoalCritic",          # Attracts robot toward goal
        "GoalAngleCritic",     # Aligns robot orientation with goal
        "PathAlignCritic",     # Keeps robot aligned with global path
        "PathFollowCritic",    # Encourages following the path closely
        "PathAngleCritic",     # Matches path orientation
        "PreferForwardCritic"  # Prefers forward motion over reverse
      ]
      
      ConstraintCritic:
        enabled: true
        cost_power: 1
        cost_weight: 4.0  # Weight for constraint violations
      
      GoalCritic:
        enabled: true
        cost_power: 1
        cost_weight: 5.0           # Strong goal attraction
        threshold_to_consider: 1.4  # meters - only apply when within this distance
      
      GoalAngleCritic:
        enabled: true
        cost_power: 1
        cost_weight: 3.0
        threshold_to_consider: 0.5
      
      PreferForwardCritic:
        enabled: true
        cost_power: 1
        cost_weight: 5.0
        threshold_to_consider: 0.5
      
      CostCritic:
        enabled: true
        cost_power: 1
        cost_weight: 3.81           # Obstacle avoidance weight
        critical_cost: 300.0        # Cost threshold for dangerous trajectories
        consider_footprint: false   # Consider full robot footprint (vs. point)
        collision_cost: 1000000.0   # Very high cost for collisions
        near_goal_distance: 1.0
        trajectory_point_step: 2    # Check every 2nd trajectory point for efficiency
      
      PathAlignCritic:
        enabled: true
        cost_power: 1
        cost_weight: 14.0           # Strong path alignment
        max_path_occupancy_ratio: 0.05
        trajectory_point_step: 4
        threshold_to_consider: 0.5
        offset_from_furthest: 20
        use_path_orientations: false
      
      PathFollowCritic:
        enabled: true
        cost_power: 1
        cost_weight: 5.0
        offset_from_furthest: 5
        threshold_to_consider: 1.4
      
      PathAngleCritic:
        enabled: true
        cost_power: 1
        cost_weight: 2.0
        offset_from_furthest: 4
        threshold_to_consider: 0.5
        max_angle_to_furthest: 1.0
        mode: 0

##############################################################################
# LOCAL COSTMAP - Rolling window around robot for obstacle avoidance
##############################################################################

local_costmap:
  local_costmap:
    ros__parameters:
      update_frequency: 5.0     # Hz - how often to update costmap
      publish_frequency: 2.0    # Hz - how often to publish costmap
      global_frame: odom        # Frame for local costmap (odom for rolling window)
      robot_base_frame: base_footprint
      rolling_window: true      # Costmap follows robot
      
      # Costmap size - INCREASED for higher speeds
      width: 5                  # meters - INCREASED from 3m (was too small for 0.8m/s)
      height: 5                 # meters - INCREASED from 3m
      resolution: 0.05          # meters/cell - 5cm resolution
      
      # Robot footprint
      robot_radius: 0.3         # meters - CORRECTED from 0.22m to actual 0.3m radius
      
      # Costmap layers (order matters!)
      plugins: ["voxel_layer", "inflation_layer"]
      
      # Inflation layer - creates cost gradient around obstacles
      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        cost_scaling_factor: 3.0      # How steeply cost drops with distance
        inflation_radius: 0.35        # meters - DECREASED from 0.4m (tighter clearance)
                                      # Now 1.17× robot radius (was 1.3×)
                                      # Robot will navigate closer to obstacles
      
      # Voxel layer - 3D obstacle detection
      voxel_layer:
        plugin: "nav2_costmap_2d::VoxelLayer"
        enabled: True
        publish_voxel_map: True
        origin_z: 0.0              # meters - ground level
        z_resolution: 0.05         # meters - vertical resolution
        z_voxels: 16               # Number of vertical voxels (16 * 0.05 = 0.8m height)
        max_obstacle_height: 2.0   # meters - ignore obstacles above this
        mark_threshold: 0          # Number of voxels to mark as obstacle
        observation_sources: scan
        
        scan:
          topic: /scan
          max_obstacle_height: 2.0
          clearing: True           # Clear obstacles that disappear
          marking: True            # Mark new obstacles
          data_type: "LaserScan"
          raytrace_max_range: 3.0  # meters - clear space up to this range
          raytrace_min_range: 0.0
          obstacle_max_range: 2.5  # meters - mark obstacles up to this range
          obstacle_min_range: 0.0
      
      always_send_full_costmap: True

##############################################################################
# GLOBAL COSTMAP - Static map for global planning
##############################################################################

global_costmap:
  global_costmap:
    ros__parameters:
      update_frequency: 1.0     # Hz - slower update for static map
      publish_frequency: 1.0    # Hz
      global_frame: map         # Frame for global costmap
      robot_base_frame: base_footprint
      robot_radius: 0.3         # meters - CORRECTED from 0.22m to actual 0.3m radius
      resolution: 0.05          # meters/cell - match local costmap resolution
      track_unknown_space: true # Track unexplored areas
      
      # Costmap layers (order matters!)
      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]
      
      # Obstacle layer - dynamic obstacles from sensors
      obstacle_layer:
        plugin: "nav2_costmap_2d::ObstacleLayer"
        enabled: True
        observation_sources: scan
        scan:
          topic: /scan
          max_obstacle_height: 2.0
          clearing: True
          marking: True
          data_type: "LaserScan"
          raytrace_max_range: 3.0
          raytrace_min_range: 0.0
          obstacle_max_range: 2.5
          obstacle_min_range: 0.0
      
      # Static layer - loads map from map_server
      static_layer:
        plugin: "nav2_costmap_2d::StaticLayer"
        map_subscribe_transient_local: True
      
      # Inflation layer - creates cost gradient around obstacles
      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        cost_scaling_factor: 3.0      # How steeply cost drops with distance
        inflation_radius: 0.55        # meters - DECREASED from 0.7m (tighter paths)
                                      # Now 1.83× robot radius (was 2.3×)
                                      # Planner will use narrower passages
      
      always_send_full_costmap: True

##############################################################################

map_saver:
  ros__parameters:
    save_map_timeout: 5.0
    free_thresh_default: 0.25      # Probability threshold for free space
    occupied_thresh_default: 0.65  # Probability threshold for occupied space
    map_subscribe_transient_local: True

##############################################################################
# PLANNER SERVER - Global path planning
##############################################################################

planner_server:
  ros__parameters:
    expected_planner_frequency: 20.0  # Hz - how often planner can be called
    planner_plugins: ["GridBased"]
    costmap_update_timeout: 1.0       # seconds - max time to wait for costmap
    
    GridBased:
      plugin: "nav2_navfn_planner::NavfnPlanner"
      tolerance: 0.5        # meters - goal tolerance for planning
      use_astar: false      # Use Dijkstra (false) or A* (true)
      allow_unknown: true   # Allow planning through unknown space

##############################################################################

smoother_server:
  ros__parameters:
    smoother_plugins: ["simple_smoother"]
    simple_smoother:
      plugin: "nav2_smoother::SimpleSmoother"
      tolerance: 1.0e-10       # Convergence tolerance
      max_its: 1000            # Maximum iterations
      do_refinement: True      # Refine path after smoothing

##############################################################################
# BEHAVIOR SERVER - Recovery behaviors (spin, backup, etc.)
##############################################################################

behavior_server:
  ros__parameters:
    local_costmap_topic: local_costmap/costmap_raw
    global_costmap_topic: global_costmap/costmap_raw
    local_footprint_topic: local_costmap/published_footprint
    global_footprint_topic: global_costmap/published_footprint
    cycle_frequency: 10.0  # Hz
    
    # Available recovery behaviors
    behavior_plugins: ["spin", "backup", "drive_on_heading", "assisted_teleop", "wait"]
    spin:
      plugin: "nav2_behaviors::Spin"
    backup:
      plugin: "nav2_behaviors::BackUp"
    drive_on_heading:
      plugin: "nav2_behaviors::DriveOnHeading"
    wait:
      plugin: "nav2_behaviors::Wait"
    assisted_teleop:
      plugin: "nav2_behaviors::AssistedTeleop"
    
    # Frame configuration
    local_frame: odom
    global_frame: map
    robot_base_frame: base_footprint
    transform_tolerance: 0.1
    
    # Behavior parameters
    simulate_ahead_time: 2.0       # seconds - look ahead for collision checking
    max_rotational_vel: 1.0        # rad/s - for spin behavior
    min_rotational_vel: 0.4        # rad/s
    rotational_acc_lim: 3.2        # rad/s² - angular acceleration limit

##############################################################################

waypoint_follower:
  ros__parameters:
    loop_rate: 20  # Hz
    stop_on_failure: false
    action_server_result_timeout: 900.0
    waypoint_task_executor_plugin: "wait_at_waypoint"
    wait_at_waypoint:
      plugin: "nav2_waypoint_follower::WaitAtWaypoint"
      enabled: True
      waypoint_pause_duration: 200  # ms - wait at each waypoint

##############################################################################
# VELOCITY SMOOTHER - Smooths cmd_vel commands for hardware safety
# Ensures acceleration/deceleration limits are respected
##############################################################################

velocity_smoother:
  ros__parameters:
    smoothing_frequency: 20.0   # Hz - MATCHES controller frequency
    scale_velocities: False     # Don't scale velocities proportionally
    feedback: "OPEN_LOOP"       # Open loop (no odometry feedback)
    
    # VELOCITY LIMITS - MUST MATCH MPPI CONTROLLER
    max_velocity: [0.8, 0.0, 1.0]     # [vx, vy, wz] in m/s and rad/s
                                       # Forward: 0.8 m/s, Angular: 1.0 rad/s
    min_velocity: [-0.35, 0.0, -1.0]  # FIXED: Was -0.5, now matches MPPI -0.35
                                       # Reverse: -0.35 m/s, Angular: -1.0 rad/s
    
    # ACCELERATION LIMITS
    max_accel: [2.5, 0.0, 3.2]   # [ax, ay, az] - maximum acceleration
    max_decel: [-2.5, 0.0, -3.2] # [ax, ay, az] - maximum deceleration
    
    odom_topic: "odom"
    odom_duration: 0.1           # seconds - odometry smoothing window
    deadband_velocity: [0.0, 0.0, 0.0]  # Velocity deadband (set to 0 to disable)
    velocity_timeout: 1.0        # seconds - timeout for velocity commands

##############################################################################
# COLLISION MONITOR - Real-time collision detection and prevention
# Acts as a safety layer between controller and hardware
##############################################################################

collision_monitor:
  ros__parameters:
    base_frame_id: "base_footprint"
    odom_frame_id: "odom"
    cmd_vel_in_topic: "cmd_vel_smoothed"   # Input from velocity smoother
    cmd_vel_out_topic: "cmd_vel"            # Output to robot hardware
    state_topic: "collision_monitor_state"
    transform_tolerance: 0.2
    source_timeout: 1.0            # seconds - sensor data timeout
    base_shift_correction: True    # Correct for base frame offset
    stop_pub_timeout: 2.0          # seconds - publish stop command timeout
    
    # Collision detection zones
    polygons: ["FootprintApproach"]
    FootprintApproach:
      type: "polygon"
      action_type: "approach"      # Slow down as obstacles approach
      footprint_topic: "/local_costmap/published_footprint"
      time_before_collision: 1.2   # seconds - warning time before collision
      simulation_time_step: 0.1    # seconds - simulation time step
      min_points: 6                # Minimum polygon points
      visualize: False
      enabled: True
    
    # Sensor sources for collision detection
    observation_sources: ["scan"]
    scan:
      type: "scan"
      topic: "scan"
      min_height: 0.15   # meters - ignore obstacles below this
      max_height: 2.0    # meters - ignore obstacles above this
      enabled: True

##############################################################################
# DOCKING SERVER - Autonomous docking for charging
##############################################################################

docking_server:
  ros__parameters:
    controller_frequency: 50.0         # Hz - docking control rate
    initial_perception_timeout: 5.0    # seconds
    wait_charge_timeout: 5.0           # seconds
    dock_approach_timeout: 30.0        # seconds
    undock_linear_tolerance: 0.05      # meters
    undock_angular_tolerance: 0.1      # radians
    max_retries: 3                     # Number of docking attempts
    base_frame: "base_footprint"
    fixed_frame: "odom"
    dock_backwards: false              # Approach dock forwards
    dock_prestaging_tolerance: 0.5     # meters
    
    # Dock types
    dock_plugins: ['simple_charging_dock']
    simple_charging_dock:
      plugin: 'opennav_docking::SimpleChargingDock'
      docking_threshold: 0.05          # meters - docked position tolerance
      staging_x_offset: -0.7           # meters - staging position offset
      use_external_detection_pose: true
      use_battery_status: false        # Set to true if using battery monitoring
      use_stall_detection: false       # Set to true if using stall detection
      
      external_detection_timeout: 1.0
      external_detection_translation_x: -0.18
      external_detection_translation_y: 0.0
      external_detection_rotation_roll: -1.57
      external_detection_rotation_pitch: -1.57
      external_detection_rotation_yaw: 0.0
      filter_coef: 0.1
    
    # Docking controller
    controller:
      k_phi: 3.0              # Proportional gain for angular error
      k_delta: 2.0            # Proportional gain for linear error
      v_linear_min: 0.15      # m/s - minimum linear velocity
      v_linear_max: 0.15      # m/s - maximum linear velocity
      use_collision_detection: true
      costmap_topic: "/local_costmap/costmap_raw"
      footprint_topic: "/local_costmap/published_footprint"
      transform_tolerance: 0.1
      projection_time: 5.0       # seconds - collision projection time
      simulation_step: 0.1       # seconds
      dock_collision_threshold: 0.3

##############################################################################
# LOOPBACK SIMULATOR - For testing without real robot
##############################################################################

loopback_simulator:
  ros__parameters:
    base_frame_id: "base_footprint"
    odom_frame_id: "odom"
    map_frame_id: "map"
    scan_frame_id: "base_scan"
    update_duration: 0.02  # seconds - 50 Hz simulation rate

##############################################################################
# END OF CONFIGURATION
##############################################################################